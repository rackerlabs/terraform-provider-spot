// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_serverclass

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func ServerclassDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"availability": schema.StringAttribute{
				Computed:            true,
				Description:         "Describes the serverclass availability status",
				MarkdownDescription: "Describes the serverclass availability status",
			},
			"category": schema.StringAttribute{
				Computed:            true,
				Description:         "Describes the serverclass category",
				MarkdownDescription: "Describes the serverclass category",
			},
			"display_name": schema.StringAttribute{
				Computed:            true,
				Description:         "Specifies the human-readable name to use",
				MarkdownDescription: "Specifies the human-readable name to use",
			},
			"flavor_type": schema.StringAttribute{
				Computed:            true,
				Description:         "Describes whether it is a VM or bare metal. This determines certain capabilities like nested virtualization",
				MarkdownDescription: "Describes whether it is a VM or bare metal. This determines certain capabilities like nested virtualization",
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "Name of the server class",
				MarkdownDescription: "Name of the server class",
			},
			"on_demand_pricing": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"cost": schema.StringAttribute{
						Computed:            true,
						Description:         "Describes the USD cost of this type of servers. If pricing is localized, this can be used as the base factor",
						MarkdownDescription: "Describes the USD cost of this type of servers. If pricing is localized, this can be used as the base factor",
					},
					"interval": schema.StringAttribute{
						Computed:            true,
						Description:         "Indicates the interval used for the pricing",
						MarkdownDescription: "Indicates the interval used for the pricing",
					},
				},
				CustomType: OnDemandPricingType{
					ObjectType: types.ObjectType{
						AttrTypes: OnDemandPricingValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"region": schema.StringAttribute{
				Computed:            true,
				Description:         "Specifies the region where the servers belonging to this ServerClass resides in",
				MarkdownDescription: "Specifies the region where the servers belonging to this ServerClass resides in",
			},
			"resources": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"cpu": schema.StringAttribute{
						Computed: true,
					},
					"memory": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: ResourcesType{
					ObjectType: types.ObjectType{
						AttrTypes: ResourcesValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"serverclass_provider": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"flavor_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Name of the flavor",
						MarkdownDescription: "Name of the flavor",
					},
					"provider_type": schema.StringAttribute{
						Computed:            true,
						Description:         "Actual infrastructure backing the server class",
						MarkdownDescription: "Actual infrastructure backing the server class",
					},
				},
				CustomType: ServerclassProviderType{
					ObjectType: types.ObjectType{
						AttrTypes: ServerclassProviderValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"available": schema.Int64Attribute{
						Computed:            true,
						Description:         "how many servers of this class are currently in use",
						MarkdownDescription: "how many servers of this class are currently in use",
					},
					"capacity": schema.Int64Attribute{
						Computed:            true,
						Description:         "how many servers of this class are currently in use",
						MarkdownDescription: "how many servers of this class are currently in use",
					},
					"last_auction": schema.Int64Attribute{
						Computed:            true,
						Description:         "how many servers of this class are currently in use",
						MarkdownDescription: "how many servers of this class are currently in use",
					},
					"reserved": schema.Int64Attribute{
						Computed:            true,
						Description:         "how many servers of this class are currently in use",
						MarkdownDescription: "how many servers of this class are currently in use",
					},
					"spot_pricing": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"hammer_price_per_hour": schema.StringAttribute{
								Computed: true,
							},
							"market_price_per_hour": schema.StringAttribute{
								Computed: true,
							},
						},
						CustomType: SpotPricingType{
							ObjectType: types.ObjectType{
								AttrTypes: SpotPricingValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
		},
	}
}

type ServerclassModel struct {
	Availability        types.String             `tfsdk:"availability"`
	Category            types.String             `tfsdk:"category"`
	DisplayName         types.String             `tfsdk:"display_name"`
	FlavorType          types.String             `tfsdk:"flavor_type"`
	Name                types.String             `tfsdk:"name"`
	OnDemandPricing     OnDemandPricingValue     `tfsdk:"on_demand_pricing"`
	Region              types.String             `tfsdk:"region"`
	Resources           ResourcesValue           `tfsdk:"resources"`
	ServerclassProvider ServerclassProviderValue `tfsdk:"serverclass_provider"`
	Status              StatusValue              `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = OnDemandPricingType{}

type OnDemandPricingType struct {
	basetypes.ObjectType
}

func (t OnDemandPricingType) Equal(o attr.Type) bool {
	other, ok := o.(OnDemandPricingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OnDemandPricingType) String() string {
	return "OnDemandPricingType"
}

func (t OnDemandPricingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	costAttribute, ok := attributes["cost"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cost is missing from object`)

		return nil, diags
	}

	costVal, ok := costAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cost expected to be basetypes.StringValue, was: %T`, costAttribute))
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return nil, diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.StringValue, was: %T`, intervalAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OnDemandPricingValue{
		Cost:     costVal,
		Interval: intervalVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewOnDemandPricingValueNull() OnDemandPricingValue {
	return OnDemandPricingValue{
		state: attr.ValueStateNull,
	}
}

func NewOnDemandPricingValueUnknown() OnDemandPricingValue {
	return OnDemandPricingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOnDemandPricingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OnDemandPricingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OnDemandPricingValue Attribute Value",
				"While creating a OnDemandPricingValue value, a missing attribute value was detected. "+
					"A OnDemandPricingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OnDemandPricingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OnDemandPricingValue Attribute Type",
				"While creating a OnDemandPricingValue value, an invalid attribute value was detected. "+
					"A OnDemandPricingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OnDemandPricingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OnDemandPricingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OnDemandPricingValue Attribute Value",
				"While creating a OnDemandPricingValue value, an extra attribute value was detected. "+
					"A OnDemandPricingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OnDemandPricingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOnDemandPricingValueUnknown(), diags
	}

	costAttribute, ok := attributes["cost"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cost is missing from object`)

		return NewOnDemandPricingValueUnknown(), diags
	}

	costVal, ok := costAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cost expected to be basetypes.StringValue, was: %T`, costAttribute))
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return NewOnDemandPricingValueUnknown(), diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.StringValue, was: %T`, intervalAttribute))
	}

	if diags.HasError() {
		return NewOnDemandPricingValueUnknown(), diags
	}

	return OnDemandPricingValue{
		Cost:     costVal,
		Interval: intervalVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewOnDemandPricingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OnDemandPricingValue {
	object, diags := NewOnDemandPricingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOnDemandPricingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OnDemandPricingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOnDemandPricingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOnDemandPricingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOnDemandPricingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOnDemandPricingValueMust(OnDemandPricingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OnDemandPricingType) ValueType(ctx context.Context) attr.Value {
	return OnDemandPricingValue{}
}

var _ basetypes.ObjectValuable = OnDemandPricingValue{}

type OnDemandPricingValue struct {
	Cost     basetypes.StringValue `tfsdk:"cost"`
	Interval basetypes.StringValue `tfsdk:"interval"`
	state    attr.ValueState
}

func (v OnDemandPricingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["cost"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interval"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Cost.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cost"] = val

		val, err = v.Interval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interval"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OnDemandPricingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OnDemandPricingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OnDemandPricingValue) String() string {
	return "OnDemandPricingValue"
}

func (v OnDemandPricingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cost":     basetypes.StringType{},
		"interval": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cost":     v.Cost,
			"interval": v.Interval,
		})

	return objVal, diags
}

func (v OnDemandPricingValue) Equal(o attr.Value) bool {
	other, ok := o.(OnDemandPricingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cost.Equal(other.Cost) {
		return false
	}

	if !v.Interval.Equal(other.Interval) {
		return false
	}

	return true
}

func (v OnDemandPricingValue) Type(ctx context.Context) attr.Type {
	return OnDemandPricingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OnDemandPricingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cost":     basetypes.StringType{},
		"interval": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ResourcesType{}

type ResourcesType struct {
	basetypes.ObjectType
}

func (t ResourcesType) Equal(o attr.Type) bool {
	other, ok := o.(ResourcesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ResourcesType) String() string {
	return "ResourcesType"
}

func (t ResourcesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cpuAttribute, ok := attributes["cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu is missing from object`)

		return nil, diags
	}

	cpuVal, ok := cpuAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu expected to be basetypes.StringValue, was: %T`, cpuAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return nil, diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.StringValue, was: %T`, memoryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ResourcesValue{
		Cpu:    cpuVal,
		Memory: memoryVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewResourcesValueNull() ResourcesValue {
	return ResourcesValue{
		state: attr.ValueStateNull,
	}
}

func NewResourcesValueUnknown() ResourcesValue {
	return ResourcesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewResourcesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ResourcesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ResourcesValue Attribute Value",
				"While creating a ResourcesValue value, a missing attribute value was detected. "+
					"A ResourcesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourcesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ResourcesValue Attribute Type",
				"While creating a ResourcesValue value, an invalid attribute value was detected. "+
					"A ResourcesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourcesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ResourcesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ResourcesValue Attribute Value",
				"While creating a ResourcesValue value, an extra attribute value was detected. "+
					"A ResourcesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ResourcesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewResourcesValueUnknown(), diags
	}

	cpuAttribute, ok := attributes["cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu is missing from object`)

		return NewResourcesValueUnknown(), diags
	}

	cpuVal, ok := cpuAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu expected to be basetypes.StringValue, was: %T`, cpuAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return NewResourcesValueUnknown(), diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.StringValue, was: %T`, memoryAttribute))
	}

	if diags.HasError() {
		return NewResourcesValueUnknown(), diags
	}

	return ResourcesValue{
		Cpu:    cpuVal,
		Memory: memoryVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewResourcesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ResourcesValue {
	object, diags := NewResourcesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewResourcesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ResourcesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewResourcesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewResourcesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewResourcesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewResourcesValueMust(ResourcesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ResourcesType) ValueType(ctx context.Context) attr.Value {
	return ResourcesValue{}
}

var _ basetypes.ObjectValuable = ResourcesValue{}

type ResourcesValue struct {
	Cpu    basetypes.StringValue `tfsdk:"cpu"`
	Memory basetypes.StringValue `tfsdk:"memory"`
	state  attr.ValueState
}

func (v ResourcesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["cpu"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["memory"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Cpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu"] = val

		val, err = v.Memory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ResourcesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ResourcesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ResourcesValue) String() string {
	return "ResourcesValue"
}

func (v ResourcesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cpu":    basetypes.StringType{},
		"memory": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cpu":    v.Cpu,
			"memory": v.Memory,
		})

	return objVal, diags
}

func (v ResourcesValue) Equal(o attr.Value) bool {
	other, ok := o.(ResourcesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cpu.Equal(other.Cpu) {
		return false
	}

	if !v.Memory.Equal(other.Memory) {
		return false
	}

	return true
}

func (v ResourcesValue) Type(ctx context.Context) attr.Type {
	return ResourcesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ResourcesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cpu":    basetypes.StringType{},
		"memory": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ServerclassProviderType{}

type ServerclassProviderType struct {
	basetypes.ObjectType
}

func (t ServerclassProviderType) Equal(o attr.Type) bool {
	other, ok := o.(ServerclassProviderType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServerclassProviderType) String() string {
	return "ServerclassProviderType"
}

func (t ServerclassProviderType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	flavorIdAttribute, ok := attributes["flavor_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flavor_id is missing from object`)

		return nil, diags
	}

	flavorIdVal, ok := flavorIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flavor_id expected to be basetypes.StringValue, was: %T`, flavorIdAttribute))
	}

	providerTypeAttribute, ok := attributes["provider_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider_type is missing from object`)

		return nil, diags
	}

	providerTypeVal, ok := providerTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider_type expected to be basetypes.StringValue, was: %T`, providerTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServerclassProviderValue{
		FlavorId:     flavorIdVal,
		ProviderType: providerTypeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewServerclassProviderValueNull() ServerclassProviderValue {
	return ServerclassProviderValue{
		state: attr.ValueStateNull,
	}
}

func NewServerclassProviderValueUnknown() ServerclassProviderValue {
	return ServerclassProviderValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServerclassProviderValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServerclassProviderValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServerclassProviderValue Attribute Value",
				"While creating a ServerclassProviderValue value, a missing attribute value was detected. "+
					"A ServerclassProviderValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServerclassProviderValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServerclassProviderValue Attribute Type",
				"While creating a ServerclassProviderValue value, an invalid attribute value was detected. "+
					"A ServerclassProviderValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServerclassProviderValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServerclassProviderValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServerclassProviderValue Attribute Value",
				"While creating a ServerclassProviderValue value, an extra attribute value was detected. "+
					"A ServerclassProviderValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServerclassProviderValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServerclassProviderValueUnknown(), diags
	}

	flavorIdAttribute, ok := attributes["flavor_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flavor_id is missing from object`)

		return NewServerclassProviderValueUnknown(), diags
	}

	flavorIdVal, ok := flavorIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flavor_id expected to be basetypes.StringValue, was: %T`, flavorIdAttribute))
	}

	providerTypeAttribute, ok := attributes["provider_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider_type is missing from object`)

		return NewServerclassProviderValueUnknown(), diags
	}

	providerTypeVal, ok := providerTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider_type expected to be basetypes.StringValue, was: %T`, providerTypeAttribute))
	}

	if diags.HasError() {
		return NewServerclassProviderValueUnknown(), diags
	}

	return ServerclassProviderValue{
		FlavorId:     flavorIdVal,
		ProviderType: providerTypeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewServerclassProviderValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServerclassProviderValue {
	object, diags := NewServerclassProviderValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServerclassProviderValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServerclassProviderType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServerclassProviderValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServerclassProviderValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServerclassProviderValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServerclassProviderValueMust(ServerclassProviderValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServerclassProviderType) ValueType(ctx context.Context) attr.Value {
	return ServerclassProviderValue{}
}

var _ basetypes.ObjectValuable = ServerclassProviderValue{}

type ServerclassProviderValue struct {
	FlavorId     basetypes.StringValue `tfsdk:"flavor_id"`
	ProviderType basetypes.StringValue `tfsdk:"provider_type"`
	state        attr.ValueState
}

func (v ServerclassProviderValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["flavor_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["provider_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.FlavorId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flavor_id"] = val

		val, err = v.ProviderType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["provider_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServerclassProviderValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServerclassProviderValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServerclassProviderValue) String() string {
	return "ServerclassProviderValue"
}

func (v ServerclassProviderValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"flavor_id":     basetypes.StringType{},
		"provider_type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"flavor_id":     v.FlavorId,
			"provider_type": v.ProviderType,
		})

	return objVal, diags
}

func (v ServerclassProviderValue) Equal(o attr.Value) bool {
	other, ok := o.(ServerclassProviderValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FlavorId.Equal(other.FlavorId) {
		return false
	}

	if !v.ProviderType.Equal(other.ProviderType) {
		return false
	}

	return true
}

func (v ServerclassProviderValue) Type(ctx context.Context) attr.Type {
	return ServerclassProviderType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServerclassProviderValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"flavor_id":     basetypes.StringType{},
		"provider_type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	availableAttribute, ok := attributes["available"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`available is missing from object`)

		return nil, diags
	}

	availableVal, ok := availableAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`available expected to be basetypes.Int64Value, was: %T`, availableAttribute))
	}

	capacityAttribute, ok := attributes["capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`capacity is missing from object`)

		return nil, diags
	}

	capacityVal, ok := capacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`capacity expected to be basetypes.Int64Value, was: %T`, capacityAttribute))
	}

	lastAuctionAttribute, ok := attributes["last_auction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_auction is missing from object`)

		return nil, diags
	}

	lastAuctionVal, ok := lastAuctionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_auction expected to be basetypes.Int64Value, was: %T`, lastAuctionAttribute))
	}

	reservedAttribute, ok := attributes["reserved"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reserved is missing from object`)

		return nil, diags
	}

	reservedVal, ok := reservedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reserved expected to be basetypes.Int64Value, was: %T`, reservedAttribute))
	}

	spotPricingAttribute, ok := attributes["spot_pricing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spot_pricing is missing from object`)

		return nil, diags
	}

	spotPricingVal, ok := spotPricingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spot_pricing expected to be basetypes.ObjectValue, was: %T`, spotPricingAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Available:   availableVal,
		Capacity:    capacityVal,
		LastAuction: lastAuctionVal,
		Reserved:    reservedVal,
		SpotPricing: spotPricingVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	availableAttribute, ok := attributes["available"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`available is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	availableVal, ok := availableAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`available expected to be basetypes.Int64Value, was: %T`, availableAttribute))
	}

	capacityAttribute, ok := attributes["capacity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`capacity is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	capacityVal, ok := capacityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`capacity expected to be basetypes.Int64Value, was: %T`, capacityAttribute))
	}

	lastAuctionAttribute, ok := attributes["last_auction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_auction is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastAuctionVal, ok := lastAuctionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_auction expected to be basetypes.Int64Value, was: %T`, lastAuctionAttribute))
	}

	reservedAttribute, ok := attributes["reserved"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reserved is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	reservedVal, ok := reservedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reserved expected to be basetypes.Int64Value, was: %T`, reservedAttribute))
	}

	spotPricingAttribute, ok := attributes["spot_pricing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spot_pricing is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	spotPricingVal, ok := spotPricingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spot_pricing expected to be basetypes.ObjectValue, was: %T`, spotPricingAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Available:   availableVal,
		Capacity:    capacityVal,
		LastAuction: lastAuctionVal,
		Reserved:    reservedVal,
		SpotPricing: spotPricingVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Available   basetypes.Int64Value  `tfsdk:"available"`
	Capacity    basetypes.Int64Value  `tfsdk:"capacity"`
	LastAuction basetypes.Int64Value  `tfsdk:"last_auction"`
	Reserved    basetypes.Int64Value  `tfsdk:"reserved"`
	SpotPricing basetypes.ObjectValue `tfsdk:"spot_pricing"`
	state       attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["available"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["capacity"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["last_auction"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["reserved"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["spot_pricing"] = basetypes.ObjectType{
		AttrTypes: SpotPricingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Available.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["available"] = val

		val, err = v.Capacity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["capacity"] = val

		val, err = v.LastAuction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_auction"] = val

		val, err = v.Reserved.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reserved"] = val

		val, err = v.SpotPricing.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spot_pricing"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var spotPricing basetypes.ObjectValue

	if v.SpotPricing.IsNull() {
		spotPricing = types.ObjectNull(
			SpotPricingValue{}.AttributeTypes(ctx),
		)
	}

	if v.SpotPricing.IsUnknown() {
		spotPricing = types.ObjectUnknown(
			SpotPricingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SpotPricing.IsNull() && !v.SpotPricing.IsUnknown() {
		spotPricing = types.ObjectValueMust(
			SpotPricingValue{}.AttributeTypes(ctx),
			v.SpotPricing.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"available":    basetypes.Int64Type{},
		"capacity":     basetypes.Int64Type{},
		"last_auction": basetypes.Int64Type{},
		"reserved":     basetypes.Int64Type{},
		"spot_pricing": basetypes.ObjectType{
			AttrTypes: SpotPricingValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"available":    v.Available,
			"capacity":     v.Capacity,
			"last_auction": v.LastAuction,
			"reserved":     v.Reserved,
			"spot_pricing": spotPricing,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Available.Equal(other.Available) {
		return false
	}

	if !v.Capacity.Equal(other.Capacity) {
		return false
	}

	if !v.LastAuction.Equal(other.LastAuction) {
		return false
	}

	if !v.Reserved.Equal(other.Reserved) {
		return false
	}

	if !v.SpotPricing.Equal(other.SpotPricing) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"available":    basetypes.Int64Type{},
		"capacity":     basetypes.Int64Type{},
		"last_auction": basetypes.Int64Type{},
		"reserved":     basetypes.Int64Type{},
		"spot_pricing": basetypes.ObjectType{
			AttrTypes: SpotPricingValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = SpotPricingType{}

type SpotPricingType struct {
	basetypes.ObjectType
}

func (t SpotPricingType) Equal(o attr.Type) bool {
	other, ok := o.(SpotPricingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpotPricingType) String() string {
	return "SpotPricingType"
}

func (t SpotPricingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hammerPricePerHourAttribute, ok := attributes["hammer_price_per_hour"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hammer_price_per_hour is missing from object`)

		return nil, diags
	}

	hammerPricePerHourVal, ok := hammerPricePerHourAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hammer_price_per_hour expected to be basetypes.StringValue, was: %T`, hammerPricePerHourAttribute))
	}

	marketPricePerHourAttribute, ok := attributes["market_price_per_hour"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`market_price_per_hour is missing from object`)

		return nil, diags
	}

	marketPricePerHourVal, ok := marketPricePerHourAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`market_price_per_hour expected to be basetypes.StringValue, was: %T`, marketPricePerHourAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpotPricingValue{
		HammerPricePerHour: hammerPricePerHourVal,
		MarketPricePerHour: marketPricePerHourVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSpotPricingValueNull() SpotPricingValue {
	return SpotPricingValue{
		state: attr.ValueStateNull,
	}
}

func NewSpotPricingValueUnknown() SpotPricingValue {
	return SpotPricingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpotPricingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpotPricingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpotPricingValue Attribute Value",
				"While creating a SpotPricingValue value, a missing attribute value was detected. "+
					"A SpotPricingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpotPricingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpotPricingValue Attribute Type",
				"While creating a SpotPricingValue value, an invalid attribute value was detected. "+
					"A SpotPricingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpotPricingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpotPricingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpotPricingValue Attribute Value",
				"While creating a SpotPricingValue value, an extra attribute value was detected. "+
					"A SpotPricingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpotPricingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpotPricingValueUnknown(), diags
	}

	hammerPricePerHourAttribute, ok := attributes["hammer_price_per_hour"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hammer_price_per_hour is missing from object`)

		return NewSpotPricingValueUnknown(), diags
	}

	hammerPricePerHourVal, ok := hammerPricePerHourAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hammer_price_per_hour expected to be basetypes.StringValue, was: %T`, hammerPricePerHourAttribute))
	}

	marketPricePerHourAttribute, ok := attributes["market_price_per_hour"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`market_price_per_hour is missing from object`)

		return NewSpotPricingValueUnknown(), diags
	}

	marketPricePerHourVal, ok := marketPricePerHourAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`market_price_per_hour expected to be basetypes.StringValue, was: %T`, marketPricePerHourAttribute))
	}

	if diags.HasError() {
		return NewSpotPricingValueUnknown(), diags
	}

	return SpotPricingValue{
		HammerPricePerHour: hammerPricePerHourVal,
		MarketPricePerHour: marketPricePerHourVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSpotPricingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpotPricingValue {
	object, diags := NewSpotPricingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpotPricingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpotPricingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpotPricingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpotPricingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpotPricingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpotPricingValueMust(SpotPricingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpotPricingType) ValueType(ctx context.Context) attr.Value {
	return SpotPricingValue{}
}

var _ basetypes.ObjectValuable = SpotPricingValue{}

type SpotPricingValue struct {
	HammerPricePerHour basetypes.StringValue `tfsdk:"hammer_price_per_hour"`
	MarketPricePerHour basetypes.StringValue `tfsdk:"market_price_per_hour"`
	state              attr.ValueState
}

func (v SpotPricingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["hammer_price_per_hour"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["market_price_per_hour"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.HammerPricePerHour.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hammer_price_per_hour"] = val

		val, err = v.MarketPricePerHour.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["market_price_per_hour"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpotPricingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpotPricingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpotPricingValue) String() string {
	return "SpotPricingValue"
}

func (v SpotPricingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"hammer_price_per_hour": basetypes.StringType{},
		"market_price_per_hour": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"hammer_price_per_hour": v.HammerPricePerHour,
			"market_price_per_hour": v.MarketPricePerHour,
		})

	return objVal, diags
}

func (v SpotPricingValue) Equal(o attr.Value) bool {
	other, ok := o.(SpotPricingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.HammerPricePerHour.Equal(other.HammerPricePerHour) {
		return false
	}

	if !v.MarketPricePerHour.Equal(other.MarketPricePerHour) {
		return false
	}

	return true
}

func (v SpotPricingValue) Type(ctx context.Context) attr.Type {
	return SpotPricingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpotPricingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"hammer_price_per_hour": basetypes.StringType{},
		"market_price_per_hour": basetypes.StringType{},
	}
}
